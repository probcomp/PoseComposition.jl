var documenterSearchIndex = {"docs":
[{"location":"#PoseComposition.jl","page":"PoseComposition.jl","title":"PoseComposition.jl","text":"","category":"section"},{"location":"","page":"PoseComposition.jl","title":"PoseComposition.jl","text":"CurrentModule = PoseComposition","category":"page"},{"location":"","page":"PoseComposition.jl","title":"PoseComposition.jl","text":"","category":"page"},{"location":"","page":"PoseComposition.jl","title":"PoseComposition.jl","text":"(Image: Illustration of Pose geometry)","category":"page"},{"location":"","page":"PoseComposition.jl","title":"PoseComposition.jl","text":"PoseComposition.jl is a library for representing and manipulating poses.  It places particular emphasis on:","category":"page"},{"location":"","page":"PoseComposition.jl","title":"PoseComposition.jl","text":"Algebraic structure.  This package implements two different group structures on poses.  In the first group structure, composition corresponds to change of coordinate frame.  This enables easy manipulation of chains of coordinate frames which occur commonly in operations on scene graphs:\ntextpose_textfloor to textnapkin = \ntextpose_textfloor to texttable *\ntextpose_texttable to textplate *\ntextpose_textplate to textnapkin\nIn the second group structure, position and orientation are treated independently; this models, e.g., inertial motion, where an object has separate translational and rotational velocities:\nbeginaligned\nmathbfx = mathbfx_0 + mathbfv_texttrans Delta t \nboldsymbolomega = boldsymbolomega_0 cdot mathbfv_textrot^Delta t\nendaligned\nInertial continuous-time dynamics are implemented concisely as interp, which is itself a special case of the exponential map on a Lie algebra:\ntextpose_t = textttinterp(textpose_0 mathbfv_textpose t)\nClear documentation.  The geometric meaning of the data structures and operations is clearly documented, so as to minimize confusion from the many ambiguities that typically plague geometry code.\nSimple equations, ergonomic code.  Because change of coordinate frame is the basic algebraic operation, large equations involving many coordinate frames can be solved via simple algebra to express the relative pose between any two frames as a function of the others.  For example, in \"Pose Algebra In Action[1],\" we solve the equation\npose1 * getContactPlane(getShape(g, :obj1), :top)\n      * planarContactTo6DOF(pc)\n== pose2 * getContactPlane(getShape(g, :obj2), :curved, 0)\nfor planarContactTo6DOF(pc) by simple division in the pose group:\nplanarContactTo6DOF(pc) ==\n    (pose1 * getContactPlane(getShape(g, :obj1), :top))\n    \\ (pose2 * getContactPlane(getShape(g, :obj2), :curved, 0))\nBy contrast, computing and expressing the position and orientation separately would require a much larger expression with nested operations and harder-to-understand code.","category":"page"},{"location":"","page":"PoseComposition.jl","title":"PoseComposition.jl","text":"[1]: The \"Pose Algebra in Action\" doc is temporarily unavailable; please check back soon!","category":"page"},{"location":"#Quick-Start","page":"PoseComposition.jl","title":"Quick Start","text":"","category":"section"},{"location":"#Pose-composition-example","page":"PoseComposition.jl","title":"Pose composition example","text":"","category":"section"},{"location":"","page":"PoseComposition.jl","title":"PoseComposition.jl","text":"Define p1, the pose of a batter (relative to some arbitrary world coordinate frame) in a game of baseball:","category":"page"},{"location":"","page":"PoseComposition.jl","title":"PoseComposition.jl","text":"p1 = Pose([10, 10, 0], UnitQuaternion(1, 0, 0, 0))","category":"page"},{"location":"","page":"PoseComposition.jl","title":"PoseComposition.jl","text":"Define p1_2, the relative pose of the baseball in the batter's coordinate frame, and compute p2, the pose of the baseball in the world coordinate frame:","category":"page"},{"location":"","page":"PoseComposition.jl","title":"PoseComposition.jl","text":"p1_2 = Pose([0, 90, 5], RotZYX(0.3, 0.4, 0.5))\np2 = p1 * p1_2","category":"page"},{"location":"","page":"PoseComposition.jl","title":"PoseComposition.jl","text":"Suppose the ball leaves the pitcher's hand at time t=0.  If the pitch is a fastball and there is negligible wind, then the ball's pose at time t can be approximated as inertial:","category":"page"},{"location":"","page":"PoseComposition.jl","title":"PoseComposition.jl","text":"# Translational and rotational velocity of the ball relative to the batter\nv = Pose([0, -115, -0.2], RotZYX(0, 0, 10))\n# Pose of the ball relative to the batter as a function of time\np1_2(t) = p2 ⊗ interp(v, t)","category":"page"},{"location":"#Point-cloud-example","page":"PoseComposition.jl","title":"Point cloud example","text":"","category":"section"},{"location":"","page":"PoseComposition.jl","title":"PoseComposition.jl","text":"Suppose a robot views the world through a camera that has pose pose_cam in the world coordinate frame, and perceives a point cloud (represented as a 3 times N matrix) ptcloud_cam in the camera's coordinate frame.  Then the same point cloud expressed in the world coordinate frame is","category":"page"},{"location":"","page":"PoseComposition.jl","title":"PoseComposition.jl","text":"ptcloud_world = pose_cam * ptcloud_cam","category":"page"},{"location":"","page":"PoseComposition.jl","title":"PoseComposition.jl","text":"Conversely, if we know of a point cloud ptcloud_world expressed in the world coordinate frame and want to re-express it in the camera's coordinate frame:","category":"page"},{"location":"","page":"PoseComposition.jl","title":"PoseComposition.jl","text":"ptcloud_cam = pose_cam \\ ptcloud_world","category":"page"},{"location":"operations/#Operations-on-Poses","page":"Operations on Poses","title":"Operations on Poses","text":"","category":"section"},{"location":"operations/","page":"Operations on Poses","title":"Operations on Poses","text":"CurrentModule = PoseComposition","category":"page"},{"location":"operations/","page":"Operations on Poses","title":"Operations on Poses","text":"","category":"page"},{"location":"operations/","page":"Operations on Poses","title":"Operations on Poses","text":"A Pose can represent either a relative pose (relative to some parent coordinate frame which must be supplied by context) or an absolute pose.  An absolute pose is, by definition, a pose relative to the world coordinate frame.","category":"page"},{"location":"operations/#First-group-structure:-change-of-coordinate-frame","page":"Operations on Poses","title":"First group structure: change of coordinate frame","text":"","category":"section"},{"location":"operations/","page":"Operations on Poses","title":"Operations on Poses","text":"A central operation on poses is change of coordinate frame:","category":"page"},{"location":"operations/","page":"Operations on Poses","title":"Operations on Poses","text":"(absolute pose of frame2) = (absolute pose of frame1) * (relative pose of frame2 relative to frame1)","category":"page"},{"location":"operations/","page":"Operations on Poses","title":"Operations on Poses","text":"This operation gives the set of poses a group structure – call it the \"pose group\" G.  This G is the opposite group of the group of rigid transformations","category":"page"},{"location":"operations/","page":"Operations on Poses","title":"Operations on Poses","text":"SE_3 = mathbbR^3 ltimes SO_3(mathbbR)","category":"page"},{"location":"operations/","page":"Operations on Poses","title":"Operations on Poses","text":"(technical note[1]), meaning that relative poses are \"applied\" on the right, rather than written as function applications on the left.","category":"page"},{"location":"operations/","page":"Operations on Poses","title":"Operations on Poses","text":"[1]: In code, elements of G whose orientation is represented as a Rotations.UnitQuaternion (as opposed to some other subtype of Rotations.Rotation{3}) remember their sign (q and -q are considered equal by Base.:==, but their fields are not equal).","category":"page"},{"location":"operations/","page":"Operations on Poses","title":"Operations on Poses","text":"The group operation is implemented via Pose-specific methods of the standard Julia functions in Base:","category":"page"},{"location":"operations/","page":"Operations on Poses","title":"Operations on Poses","text":"Multiplication: pose1 * pose2\nInversion: inv(pose), such that pose * inv(pose) == inv(pose) * pose == IDENTITY_POSE\nRight-division: pose1 / pose2 := pose1 * inv(pose2)\nLeft-division: pose1 \\ pose2 := inv(pose1) * pose2","category":"page"},{"location":"operations/#Convention:-First-translate,-then-rotate","page":"Operations on Poses","title":"Convention: First translate, then rotate","text":"","category":"section"},{"location":"operations/","page":"Operations on Poses","title":"Operations on Poses","text":"Note that we define the group operation on the pose group by doing the translation first, then the rotation.  So the coordinate frame pose1 * pose2 has an origin whose coordinates in the frame of pose1 are pose2.pos (the translational component of pose2).","category":"page"},{"location":"operations/","page":"Operations on Poses","title":"Operations on Poses","text":"Note also that the orientation orn := pose.orientation represents the linear operator","category":"page"},{"location":"operations/","page":"Operations on Poses","title":"Operations on Poses","text":"v ↦ Rotations.RotMatrix{3}(orn) * v   =:   orn * v","category":"page"},{"location":"operations/","page":"Operations on Poses","title":"Operations on Poses","text":"In other words, we are using the convention that matrix-vector multiplication has the vector on the right.  The x, y and z axes of an object with pose pose are pose.orientation * [1, 0, 0], pose.orientation * [0, 1, 0] and pose.orientation * [0, 0, 1] respectively.","category":"page"},{"location":"operations/#Example:-Which-order-do-I-multiply-things-in?","page":"Operations on Poses","title":"Example: Which order do I multiply things in?","text":"","category":"section"},{"location":"operations/","page":"Operations on Poses","title":"Operations on Poses","text":"Suppose we start with coordinate frame p1, and we want to translate its origin by p2.pos and then rotate its coordinate axes via the linear map v ↦ p2.orientation * v.  Would the pose corresponding to the new coordinate frame be written as p1 * p2 or p2 * p1?","category":"page"},{"location":"operations/","page":"Operations on Poses","title":"Operations on Poses","text":"Answer: p1 * p2.","category":"page"},{"location":"operations/#Mathematical-details:-contravariance,-coordinate-frames,-and-rigid-motions","page":"Operations on Poses","title":"Mathematical details: contravariance, coordinate frames, and rigid motions","text":"","category":"section"},{"location":"operations/","page":"Operations on Poses","title":"Operations on Poses","text":"There are two ways to think about poses:","category":"page"},{"location":"operations/","page":"Operations on Poses","title":"Operations on Poses","text":"A pose is a coordinate frame, described with respect to some other base coordinate frame.  The pos says where the frame's origin is, and the orientation says what directions its orthonormal axes point in.\nA pose is a rigid motion.  The translational component is pos and the orientation component is the linear map v ↦ orientation * v.","category":"page"},{"location":"operations/","page":"Operations on Poses","title":"Operations on Poses","text":"When we talk about the group action of G on itself by multiplication, we want to say that a rigid transformation (way 2 above) acts on a coordinate frame (way 1 above), by moving the origin a translational offset of pos and matrix-multiplying its rotation by orientation.  The thing to note is that, even though function application is usually written on the left, this group action right-associative, so it must be represented by right-multiplication, not left-multiplication (or else the associative law breaks).","category":"page"},{"location":"operations/#Points-and-point-clouds","page":"Operations on Poses","title":"Points and point clouds","text":"","category":"section"},{"location":"operations/","page":"Operations on Poses","title":"Operations on Poses","text":"Above we explained how a pose can act on another pose.  It is also possible for a pose to act on a point in mathbbR^3.  To see how, note that for poses a and b, the position of the product, (a * b).pos, does not depend on b.orientation.  Therefore it is valid to define, for any a::Pose and any textttbpos  mathbbR^3,","category":"page"},{"location":"operations/","page":"Operations on Poses","title":"Operations on Poses","text":"a * bpos := (a * Pose(bpos, orn)).pos","category":"page"},{"location":"operations/","page":"Operations on Poses","title":"Operations on Poses","text":"where orn is any orientation (and its value does not affect the result).","category":"page"},{"location":"operations/","page":"Operations on Poses","title":"Operations on Poses","text":"In words, a * bpos is the coordinates in the world frame of the vector whose coordinates in the frame represented by a are bpos.","category":"page"},{"location":"operations/","page":"Operations on Poses","title":"Operations on Poses","text":"From this it's straightforward to see that the usual associativity law holds:","category":"page"},{"location":"operations/","page":"Operations on Poses","title":"Operations on Poses","text":"a * (b * cpos) = (a * b) * cpos","category":"page"},{"location":"operations/","page":"Operations on Poses","title":"Operations on Poses","text":"Therefore pose–point multiplication is indeed a group action of G on mathbbR^3.","category":"page"},{"location":"operations/","page":"Operations on Poses","title":"Operations on Poses","text":"This package implements both Pose * point and a vectorized version, Pose * pointcloud, where pointcloud is a 3  N matrix in which each column represents a point:","category":"page"},{"location":"operations/","page":"Operations on Poses","title":"Operations on Poses","text":"julia> Pose([1, 2, 3], RotZYX(0.4, 0.5, 0.6)) * @SVector([7, 8, 9])\n\n3-element StaticArrays.SArray{Tuple{3},Float64,1,3} with indices SOneTo(3):\n 11.340627918648092\n  8.023198113213361\n 10.126885626769848\n\njulia> Pose([1, 2, 3], RotZYX(0.4, 0.5, 0.6)) * [7  10  13  16;\n                                                 8  11  14  17;\n                                                 9  12  15  18]\n\n3×4 Array{Float64,2}:\n 11.3406  15.3024  19.2641  23.2258\n  8.0232  10.5473  13.0714  15.5955\n 10.1269  12.3481  14.5693  16.7904","category":"page"},{"location":"operations/#Second-group-structure:-direct-product-of-position-and-orientation","page":"Operations on Poses","title":"Second group structure: direct product of position and orientation","text":"","category":"section"},{"location":"operations/","page":"Operations on Poses","title":"Operations on Poses","text":"The composition operation described above and denoted by * is useful when manipulating chains of relative poses, which commonly occur in scene graphs. We now define a second group structure on the set of Poses: the direct product mathbbR^3  SO_3(mathbbR).  We denote the group operation in this second structure by ⊗, and it means \"add the positions and (separately) compose the orientations.\"  This operation models inertial motion, where an object has separate translational and rotational velocities:","category":"page"},{"location":"operations/","page":"Operations on Poses","title":"Operations on Poses","text":"beginaligned\nmathbfx = mathbfx_0 + Δmathbfx \nboldsymbolω = boldsymbolω_0 cdot Δboldsymbolω\nendaligned","category":"page"},{"location":"operations/","page":"Operations on Poses","title":"Operations on Poses","text":"or simply","category":"page"},{"location":"operations/","page":"Operations on Poses","title":"Operations on Poses","text":"pose1 = pose0 ⊗ Δpose","category":"page"},{"location":"operations/","page":"Operations on Poses","title":"Operations on Poses","text":"This second group operation is implemented via the following infix operators:","category":"page"},{"location":"operations/","page":"Operations on Poses","title":"Operations on Poses","text":"Multiplication: pose1 ⊗ pose2 (LaTeX: \\otimes)\nRight-division: pose1 ⊘ pose2 (LaTeX: \\oslash)\nLeft-division: pose1 ⦸ pose2 (LaTeX: \\obslash)","category":"page"},{"location":"operations/","page":"Operations on Poses","title":"Operations on Poses","text":"The direct product structure is useful for performing computations that treat translational and rotational components separately, such as computing the pose of a moving object by integrating its velocity.  The translational and rotational components of the velocity are integrated separately – in differential geometry terms, motion is governed by the exponential map on the Lie algebra of mathbbR^3  SO_3(mathbbR), not the Lie algebra of SE_3.","category":"page"},{"location":"operations/#Inter/Extrapolation,-a.k.a.-stepping-time-forward-a-fractional-number-of-times","page":"Operations on Poses","title":"Inter/Extrapolation, a.k.a. stepping time forward a fractional number of times","text":"","category":"section"},{"location":"operations/","page":"Operations on Poses","title":"Operations on Poses","text":"One nice property of the direct product (and its physical application of integrating a velocity) is that there is a straightforward analogue of the physics 101 equation","category":"page"},{"location":"operations/","page":"Operations on Poses","title":"Operations on Poses","text":"mathbfx = mathbfx_0 + t mathbfv","category":"page"},{"location":"operations/","page":"Operations on Poses","title":"Operations on Poses","text":"where mathbfx_0 is the initial displacement of an object, t is time, and mathbfv is the object's velocity, which is assumed to stay constant. That analogue is","category":"page"},{"location":"operations/","page":"Operations on Poses","title":"Operations on Poses","text":"pose = pose0 ⊗ interp(v, t)","category":"page"},{"location":"operations/","page":"Operations on Poses","title":"Operations on Poses","text":"where pose, pose0 and v are Poses, and t is a Real.  The function interp defines how to interpolate between doing nothing and translating by v.pos (namely, scalar multiplication) and how to interpolate between doing nothing and applying the rotation v.orientation (namely, SLERP).","category":"page"},{"location":"operations/","page":"Operations on Poses","title":"Operations on Poses","text":"There is also a variant of interp that takes two pose arguments and interpolates between them:","category":"page"},{"location":"operations/","page":"Operations on Poses","title":"Operations on Poses","text":"pose = interp(pose0, pose1, t)","category":"page"},{"location":"operations/","page":"Operations on Poses","title":"Operations on Poses","text":"which is equivalent to","category":"page"},{"location":"operations/","page":"Operations on Poses","title":"Operations on Poses","text":"pose = pose0 ⊗ interp(pose0 ⦸ pose1, t)","category":"page"},{"location":"operations/","page":"Operations on Poses","title":"Operations on Poses","text":"In particular, we have pose = pose0 when t = 0 and pose = pose1 when t = 1.","category":"page"},{"location":"further_api_reference/#Further-API-Reference","page":"Further API Reference","title":"Further API Reference","text":"","category":"section"},{"location":"further_api_reference/","page":"Further API Reference","title":"Further API Reference","text":"CurrentModule = PoseComposition","category":"page"},{"location":"further_api_reference/","page":"Further API Reference","title":"Further API Reference","text":"Modules = [PoseComposition]\nOrder = [:type, :function]","category":"page"},{"location":"further_api_reference/#PoseComposition.Pose","page":"Further API Reference","title":"PoseComposition.Pose","text":"Fields:\n\npos::StaticArrays.StaticArray{Tuple{3},#s12,1} where #s12<:Real\nOrigin of the object's coordinate frame.\norientation::Rotations.Rotation{3,T} where T\nOrientation of the object's coordinate frame.\n\n\n\nStruct representing the pose (position and orientation) of an object.\n\nCan represent either a relative pose (relative to some parent coordinate frame which must be supplied by context) or an absolute pose.  An absolute pose is, by definition, a pose relative to the world coordinate frame.\n\nSee Operations on Poses for documentation of this data structure and the operations defined on it.\n\n\n\n\n\n","category":"type"},{"location":"further_api_reference/#Base.:*-Tuple{PoseComposition.Pose,AbstractArray{#s17,2} where #s17<:Real}","page":"Further API Reference","title":"Base.:*","text":"*(a::PoseComposition.Pose, bpoints::AbstractArray{#s17,2} where #s17<:Real) -> Any\n\n\nVectorized pose–point multiplication.  Returns the matrix whose ith column is a * bpoints[:, i].\n\nThe matrix bpoints must have 3 rows, as each column represents a point in 3D space.\n\n\n\n\n\n","category":"method"},{"location":"further_api_reference/#Base.:\\-Tuple{PoseComposition.Pose,AbstractArray{#s17,2} where #s17<:Real}","page":"Further API Reference","title":"Base.:\\","text":"\\(a::PoseComposition.Pose, bpoints::AbstractArray{#s17,2} where #s17<:Real) -> Any\n\n\nVectorized version of pose–point left division.  Returns the matrix whose ith column is a \\ bpoints[:, i].\n\nThe matrix bpoints must have 3 rows, as each column represents a point in 3D space.\n\n\n\n\n\n","category":"method"},{"location":"further_api_reference/#PoseComposition.geodesicHopf-Tuple{StaticArrays.StaticArray{Tuple{3},#s17,1} where #s17<:Real,Real}","page":"Further API Reference","title":"PoseComposition.geodesicHopf","text":"geodesicHopf(newZ::StaticArrays.StaticArray{Tuple{3},#s17,1} where #s17<:Real, planarAngle::Real) -> Rotations.UnitQuaternion{_A} where _A\n\n\nnote: TODO\nThis code mostly duplicates GenDirectionalStats.hopf.  The two should probably be consolidated into one.\n\nReturns a rotation that carries the z-axis to newZ, with the remaining degree of freedom determined by planarAngle as described below.\n\nStart with the case planarAngle = 0.  In that case, the returned rotation is the unique (except at singularities) rotation that carries [0, 0, 1] to newZ \"along a great circle\" (more precisely: the unique rotation that carries [0, 0, 1] to newZ and whose equator contains [0, 0, 1] and newZ; \"equator\" means the unique great circle that is fixed setwise by the rotation).\n\nNext consider the general case.  This works the same as the above special case, except that we precede that rotation with a rotation by angle planarAngle around [0, 0, 1] (or equivalently, we follow that rotation with a rotation by planarAngle around newZ).\n\nThe name of this function comes from the fact that we are using geodesics (great circles) to define a coordinate chart on the fiber over newZ  in the Hopf fibration.\n\nSee also: invGeodesicHopf\n\n\n\n\n\n","category":"method"},{"location":"further_api_reference/#PoseComposition.interp-Tuple{PoseComposition.Pose,PoseComposition.Pose,Real}","page":"Further API Reference","title":"PoseComposition.interp","text":"interp(a::PoseComposition.Pose, b::PoseComposition.Pose, t::Real) -> PoseComposition.Pose\n\n\nLike interp, but interpolates between two given poses rather than always starting at the identity.  That is,\n\ninterp(a, b, 0) == a\ninterp(a, b, 1) == b\n\nand as a special case, we have\n\ninterp(b, t) == interp(IDENTITY_POSE, b, t)\n\n\n\n\n\n","category":"method"},{"location":"further_api_reference/#PoseComposition.interp-Tuple{PoseComposition.Pose,Real}","page":"Further API Reference","title":"PoseComposition.interp","text":"interp(b::PoseComposition.Pose, t::Real) -> PoseComposition.Pose\n\n\nInterpolates between the identity pose and b.\n\nNamely, interp(b, 0) == IDENTITY_POSE and interp(b, 1) == b.  The position is interpolated linearly and the orientation is interpolated by quaternion SLERP.  That is, this interpolation treats position and orientation independently, as in the ⊗ operation (not the * operation).\n\n\n\n\n\n","category":"method"},{"location":"further_api_reference/#PoseComposition.invGeodesicHopf-Tuple{Rotations.Rotation{3,T} where T}","page":"Further API Reference","title":"PoseComposition.invGeodesicHopf","text":"invGeodesicHopf(r::Rotations.Rotation{3,T} where T) -> NamedTuple{(:newZ, :planarAngle),_A} where _A<:Tuple\n\n\nInverse function of geodesicHopf.\n\nSatisfies the round-trip conditions\n\ngeodesicHopf(invGeodesicHopf(r)...) == r\n\nand\n\ninvGeodesicHopf(geodesicHopf(newZ, planarAngle))\n== (newZ=newZ, planarAngle=planarAngle)\n\n\n\n\n\n","category":"method"},{"location":"further_api_reference/#PoseComposition.isapproxIncludingQuaternionSign-Tuple{PoseComposition.Pose,PoseComposition.Pose}","page":"Further API Reference","title":"PoseComposition.isapproxIncludingQuaternionSign","text":"isapproxIncludingQuaternionSign(a::PoseComposition.Pose, b::PoseComposition.Pose; kwargs)\n\n\nLike isapprox, but does not consider a quaternion to be equivalent to its negative (even though they correspond to the same rotation matrix).  Note that this is stricter than Base.isapprox, since for a Rotations.UnitQuaternion q, we have -q ≈ q and in fact -q == q.\n\n\n\n\n\n","category":"method"}]
}
